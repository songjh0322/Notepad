일반적인 함수의 사용과 호출

fun add(a:Int,b:Int,c:Int):Int{
	return a+b+c
}
--> 단일 표현식 함수로 변환

fun add(a:Int,b:Int,c:Int)=a+b+c

단일 표현식 함수에서는 반환타입의 추론이 가능하므로 반환형을 생략할 수 있다.
코틀린에서 함수는 내부적으로 기능을 가진 형태이지만
외부에서 볼 때는 파라미터를 넣는다는 점 외에는
자료형이 결정된 변수라는 개념으로 접근하는 것이 좋다.

fun main() {
	dowhen(1)
	dowhen("Dimo")
	dowhen(12L)
	dowhen(2)
}


fun doWhen (a :Any){ //Any : 최상위 자료형 (모두 호환가능)

	when(a) {
	1 -> println("정수 1입니다")
	"Dimo" -> println("디모의 코틀린 강좌입니다.")
	is Long -> println("Long타입 입니다.")
	!is String -> println("String 타입이 아닙니다")
	else -> println("어떤 조건도 만족하지 않습니다.")
	}
	
}

//when의 조건이 맞을 때 동작 대신 값을 반환하는 표현식으로서의 역할
fun doWhen (a :Any){ //Any : 최상위 자료형 (모두 호환가능)

	var result =when(a) {
		1 -> "정수 1입니다"
		"Dimo" -> "디모의 코틀린 강좌입니다."
		is Long ->"Long타입 입니다."
		!is String -> "String 타입이 아닙니다"
		else -> "어떤 조건도 만족하지 않습니다."
	}
	
	println(result)
	
}

for(i in 0..9) //기존 언어들의 구조와는 다르다.
for(i in 0..9 step 3) //오!
for(i in 9 downTo 0)
for(i in 9 downto 0 step 3)
for(i in 'a'..'e') //이거도 돼?



for( i in 1..10) {
	for( j in 1..10) {
		if( i == 1 && j == 2) break
		}
		//또 체크...
	}


--> 고전적인 언어에서는 내부 반복문에서 break가 걸려도
외부 반복문에서 또 다시 조건을 체크하여 모든 반복문을 수동으로 종료해야만 한다.

for( i in 1..10) {
	loop@for( j in 1..10) {
		if( i == 1 && j == 2) break@loop
		}
	}

-->코틀린에서는 레이블이 달린 반복문을 기준으로 즉시 break를 시켜준다. 물론 continue인 경우에도 마찬가지.

